/*@!Encoding:1252*/
includes
{
  #include "..\source_files\MakeBeforeBreak.cin"
}

variables
{
  int sensor_status;
  int requests_failed;
  int sim_mode;
  int res;
  
  msTimer timer1ms_EGSMcyclicRequest;
  msTimer timer1ms_AGSMcyclicRequest;
  timer timer5s_search;
  diagRequest Hall_Sensors_Read EGSM_hall_req;
  diagRequest AGSM_sensor_position_Read AGSM_hall_req;
  byte hall_respBuffer[6];
}

on start
{
  requests_failed = 0;
  sim_mode = getValue(Mode_Select);
  switch (sim_mode)
  {
    case 0: //simulator mode, set no target
      break;
      
    case 1: //EGSM 3 sensor shifter mode
      if ( 0 == diagSetTarget("EGSM"))//set the target to EGSM and stat its cyclic timer
        setTimerCyclic(timer1ms_EGSMcyclicRequest, 11);
      break;
      
    case 2: //"AGSM" 5 sensor shifter mode
      if ( 0 == diagSetTarget("_952_AGSM_Automatic_Gearbox_Shifter_Module"))//set the target to the "AGSM" and stat its cyclic timer
        setTimerCyclic(timer1ms_AGSMcyclicRequest, 11);
      break;
      
    default:
        //default state for safety reasons, do nothing if entering here
        //as this runs on start up it should reasonably never enter here
        //Send out a warning if it does
        write("*** Entered default state on startup!");
      break;
  }
  sim_mode = 0;//reset sim_mode in case something happens elesewhere
}

//Controlls the selecting on which module sends input to 
on envVar Mode_Select
{
  cancelTimer(timer5s_search);//stop the searching timer in case it was running
  sim_mode = getValue(Mode_Select);
  switch (sim_mode)
  {
    case 0: //simulator mode, set no target and disable timers
      //start simulation and stop "AGSM" timer
      cancelTimer(timer1ms_AGSMcyclicRequest);
      write("Searching ended, entering simulation mode.");
      break;
      
    case 1: //EGSM 3 sensor shifter mode
      if ( 0 == diagSetTarget("EGSM"))//set the target to EGSM and stat its cyclic timer
      {
        //stop simulation and start EGSM timer
        setTimerCyclic(timer1ms_EGSMcyclicRequest, 11);
      }
      break;
      
    case 2: //"AGSM" 5 sensor shifter mode
      if ( 0 == diagSetTarget("_952_AGSM_Automatic_Gearbox_Shifter_Module"))//set the target to the "AGSM" and stat its cyclic timer
      {
        //stop EGSM timer and start "AGSM" timer
        cancelTimer(timer1ms_EGSMcyclicRequest);
        setTimerCyclic(timer1ms_AGSMcyclicRequest, 11);
      }
      break;
      
    default:
        //default state for safety reasons, do nothing if entering here
        //If Mode_Select gets forced to anything other than 0:1:2 during rutime it will go in here
        //Send out a warning if it does
        write("*** Entered default state for Mode_Select!");
      break;
  }
  sim_mode = 0;//reset sim_mode in case something happens elesewhere
}
on timer timer5s_search
{
  //Restart the timer for the selected shifter if it stopped for any reason
  write("Retrying connection...");
  sim_mode = getValue(Mode_Select);
  switch (sim_mode)
  {
    //Restart the selected timer (based on Mode_Select) in an attempt to restore the connection to the shifter
    case 1: //EGSM 3 sensor shifter mode
      if ( 0 == diagSetTarget("EGSM"))
        setTimerCyclic(timer1ms_EGSMcyclicRequest, 11);
      break;
      
    case 2: //"AGSM" 5 sensor shifter mode
      if ( 0 == diagSetTarget("_952_AGSM_Automatic_Gearbox_Shifter_Module"))
        setTimerCyclic(timer1ms_AGSMcyclicRequest, 11);
      break;
      
    default:
        //default state enters if timer5 gets started during simulation mode or if an error occurs
        //Normal runtime shouldn't enter, unless timer5s times out and the select button is in simulator mode
        write("Entered default state during search for shifter.\nIf the mode-select button currently is in sim mode, ignore this message.");
      break;
  }
  sim_mode = 0;//reset sim_mode in case something happens elesewhere
}

//Sends requests to the correct module
on timer timer1ms_EGSMcyclicRequest
{
  if ( diagSendRequest(EGSM_hall_req) < 0)
  {
    write("*** Error calling DiagSendRequest!");
    requests_failed++;
    if (requests_failed > 5)
    {
      setTimer(timer5s_search, 5);            //set a timer to wait 5 seconds before retrying the connection
      cancelTimer(timer1ms_EGSMcyclicRequest);//cancel the cyclic timer to not interfere with the search timer
      requests_failed = 0;
      write("Searching...");
    }
  }
  else requests_failed = 0;
}
on timer timer1ms_AGSMcyclicRequest
{
  if ( diagSendRequest(AGSM_hall_req) < 0)
  {
    write("*** Error calling DiagSendRequest!");
    requests_failed++;
    if (requests_failed > 5)
    {
      setTimer(timer5s_search, 5);            //set a timer to wait 5 seconds before retrying the connection
      cancelTimer(timer1ms_AGSMcyclicRequest);//cancel the cyclic timer to not interfere with the search timer
      requests_failed = 0;
      write("Searching...");
    }
  }
  else requests_failed = 0;
}

//waits on responses xdr
on diagResponse EGSM.Classes::DIDs::Hall_Sensors_Read
{
  this.GetPrimitiveData(hall_respBuffer, 6);
  write("%x %x %x %x %x %x", hall_respBuffer[0],hall_respBuffer[1],hall_respBuffer[2],hall_respBuffer[3],hall_respBuffer[4],hall_respBuffer[5]);
  
  //data=0x0_: hall_respBuffer[3]
  //convert response to correct MBB input
  sensor_status = 0;
  sensor_status |= (hall_respBuffer[3] & 0x10) >> 4;
  sensor_status |= (hall_respBuffer[3] & 0x08) >> 2;
  sensor_status |= (hall_respBuffer[3] & 0x04) << 2;
  sensor_status |= (hall_respBuffer[3] & 0x02) << 1;
  sensor_status |= (hall_respBuffer[3] & 0x01) << 3;
  
  MBB(sensor_status);
}
on diagResponse _952_AGSM_Automatic_Gearbox_Shifter_Module.Classes::EngeneeringParameters::AGSM_sensor_position_Read
{
  this.GetPrimitiveData(hall_respBuffer, 6);
  write("%x %x %x %x %x %x", hall_respBuffer[0],hall_respBuffer[1],hall_respBuffer[2],hall_respBuffer[3],hall_respBuffer[4],hall_respBuffer[5]);
  
  //TODO: convert bytes to MBB input
  sensor_status = 0;
  //WARNING: THE FOLLOWING CODE IS NOT SAFE, DO NOT USE IN TAIWAN!
  //it assumes that the raw data is in hall_respBuffer for now
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x40) >> 6;
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x20) >> 4;
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x10) << 1;
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x08);
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x04);
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x02) << 3;
  sensor_status |= (hall_respBuffer[3]/*PLACEHOLDER*/ & 0x01) << 6;
  
  
  //MBB(sensor_status);
}
